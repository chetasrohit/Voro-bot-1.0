================================================================================
SQLITE3 - DETAILED BEGINNER'S GUIDE WITH SYNTAX EXPLANATIONS
================================================================================

This is a comprehensive, beginner-friendly guide to using SQLite3 in Node.js.
For quick reference, see the summary above. This section provides detailed
explanations with examples for every operation.

WHAT IS SQLITE?
SQLite is like an Excel spreadsheet, but for programmers! It stores data in
tables (like spreadsheet tabs) with rows and columns. Unlike other databases,
SQLite doesn't need a separate server - it's just a file on your computer!

================================================================================
1. CREATING AND OPENING DATABASES
================================================================================

SYNTAX:
const sqlite3 = require('sqlite3').verbose();
const db = new sqlite3.Database(filename, mode, callback);

PARAMETERS EXPLAINED:
- filename: Path to database file (string)
  * 'mydata.db' - creates/opens file in current directory
  * './data/mydata.db' - creates/opens in data folder
  * ':memory:' - temporary database (lost when program ends)

- mode (optional): How to open the database
  * sqlite3.OPEN_READWRITE - Read and write (default)
  * sqlite3.OPEN_READONLY - Read only (can't modify)
  * sqlite3.OPEN_CREATE - Create if doesn't exist
  * Can combine: sqlite3.OPEN_READWRITE | sqlite3.OPEN_CREATE

- callback (optional): Function called after opening
  * Receives (err) parameter
  * err is null if successful, error object if failed

EXAMPLE 1 - Simple Open:
const sqlite3 = require('sqlite3').verbose();
const db = new sqlite3.Database('mydata.db');

WHAT HAPPENS:
- Creates mydata.db if it doesn't exist
- Opens it if it already exists
- Ready to use immediately!

EXAMPLE 2 - With Error Handling:
const db = new sqlite3.Database('mydata.db', (err) => {
  if (err) {
    console.error('Error opening database:', err.message);
  } else {
    console.log('Connected to database successfully!');
  }
});

EXAMPLE 3 - Read-Only Mode:
const db = new sqlite3.Database('mydata.db', sqlite3.OPEN_READONLY, (err) => {
  if (err) {
    console.error(err.message);
  } else {
    console.log('Opened database in read-only mode');
  }
});

EXAMPLE 4 - In-Memory Database (Temporary):
const db = new sqlite3.Database(':memory:', (err) => {
  if (err) {
    console.error(err.message);
  } else {
    console.log('Created temporary in-memory database');
  }
});

USE CASES:
- Regular file: Permanent storage
- Read-only: Viewing data without risk of changes
- In-memory: Testing, temporary data, fast operations

================================================================================
2. CREATING TABLES
================================================================================

SYNTAX:
db.run(sql, params, callback);

SQL CREATE TABLE SYNTAX:
CREATE TABLE IF NOT EXISTS table_name (
  column1 datatype constraints,
  column2 datatype constraints,
  ...
)

DATA TYPES:
- INTEGER: Whole numbers (1, 2, 3, -5, 100, 999999)
- TEXT: Strings ("hello", "john@email.com", "any text")
- REAL: Decimal numbers (3.14, 99.99, -0.5)
- BLOB: Binary data (images, files, raw bytes)
- NULL: No value (empty)

CONSTRAINTS:
- PRIMARY KEY: Unique identifier for each row
- AUTOINCREMENT: Automatically increases (1, 2, 3...)
- NOT NULL: Field cannot be empty
- UNIQUE: No two rows can have same value
- DEFAULT value: Use this value if none provided

EXAMPLE 1 - Simple Users Table:
db.run(`
  CREATE TABLE IF NOT EXISTS users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    username TEXT NOT NULL,
    email TEXT NOT NULL UNIQUE,
    password TEXT NOT NULL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
  )
`, (err) => {
  if (err) {
    console.error('Error creating table:', err.message);
  } else {
    console.log('Table created successfully!');
  }
});

BREAKDOWN:
- CREATE TABLE IF NOT EXISTS: Only create if table doesn't exist yet
- users: Name of the table
- id INTEGER PRIMARY KEY AUTOINCREMENT:
  * id: Column name
  * INTEGER: Stores whole numbers
  * PRIMARY KEY: This is the unique identifier
  * AUTOINCREMENT: Automatically 1, 2, 3, 4...
- username TEXT NOT NULL:
  * username: Column name
  * TEXT: Stores text/strings
  * NOT NULL: Cannot be empty
- email TEXT NOT NULL UNIQUE:
  * UNIQUE: No two users can have same email
- created_at DATETIME DEFAULT CURRENT_TIMESTAMP:
  * Automatically sets to current date/time when row is created

EXAMPLE 2 - Products Table:
db.run(`
  CREATE TABLE IF NOT EXISTS products (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    description TEXT,
    price REAL NOT NULL,
    stock INTEGER DEFAULT 0,
    category TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
  )
`, (err) => {
  if (err) console.error(err.message);
  else console.log('Products table created!');
});

EXAMPLE 3 - Posts Table with Foreign Key:
db.run(`
  CREATE TABLE IF NOT EXISTS posts (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER NOT NULL,
    title TEXT NOT NULL,
    content TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id)
  )
`, (err) => {
  if (err) console.error(err.message);
  else console.log('Posts table created!');
});

FOREIGN KEY EXPLAINED:
- Links posts to users
- user_id in posts must match an id in users table
- Ensures data integrity (can't create post for non-existent user)

================================================================================
3. INSERTING DATA (Adding Rows)
================================================================================

SYNTAX:
db.run("INSERT INTO table (col1, col2) VALUES (?, ?)", [val1, val2], callback);

IMPORTANT: ALWAYS USE ? PLACEHOLDERS!
- Bad:  `INSERT INTO users VALUES ('${name}', '${email}')`  // SQL INJECTION RISK!
- Good: `INSERT INTO users VALUES (?, ?)`, [name, email]   // SAFE!

EXAMPLE 1 - Insert Single User:
db.run(
  "INSERT INTO users (username, email, password) VALUES (?, ?, ?)",
  ['john_doe', 'john@example.com', 'hashed_password_here'],
  function(err) {
    if (err) {
      console.error('Error inserting user:', err.message);
    } else {
      console.log(`User inserted with ID: ${this.lastID}`);
      console.log(`Rows affected: ${this.changes}`);
    }
  }
);

IMPORTANT NOTES:
- Use function(err) NOT arrow function => to access this.lastID
- this.lastID: The ID of the newly inserted row
- this.changes: Number of rows affected (should be 1 for insert)

EXAMPLE 2 - Insert with All Fields:
const username = 'alice';
const email = 'alice@example.com';
const password = 'hashed_pass';

db.run(
  `INSERT INTO users (username, email, password) VALUES (?, ?, ?)`,
  [username, email, password],
  function(err) {
    if (err) {
      if (err.message.includes('UNIQUE')) {
        console.log('Email already exists!');
      } else {
        console.error(err.message);
      }
    } else {
      console.log(`New user ID: ${this.lastID}`);
    }
  }
);

EXAMPLE 3 - Insert Multiple Users (Efficient Way):
const users = [
  ['alice', 'alice@example.com', 'pass1'],
  ['bob', 'bob@example.com', 'pass2'],
  ['charlie', 'charlie@example.com', 'pass3']
];

// Prepare statement once
const stmt = db.prepare("INSERT INTO users (username, email, password) VALUES (?, ?, ?)");

// Execute multiple times
users.forEach(user => {
  stmt.run(user, (err) => {
    if (err) {
      console.error(`Error inserting ${user[0]}:`, err.message);
    } else {
      console.log(`Inserted ${user[0]}`);
    }
  });
});

// IMPORTANT: Always finalize!
stmt.finalize((err) => {
  if (err) console.error(err.message);
  else console.log('All users inserted!');
});

WHY PREPARED STATEMENTS?
- Compiles SQL once, executes many times
- Much faster for multiple inserts
- Still protects against SQL injection

EXAMPLE 4 - Insert and Get the New Row:
db.run(
  "INSERT INTO users (username, email, password) VALUES (?, ?, ?)",
  ['david', 'david@example.com', 'pass'],
  function(err) {
    if (err) {
      console.error(err.message);
    } else {
      const newId = this.lastID;
      
      // Now get the full row we just inserted
      db.get("SELECT * FROM users WHERE id = ?", [newId], (err, row) => {
        if (err) {
          console.error(err.message);
        } else {
          console.log('Newly inserted user:', row);
        }
      });
    }
  }
);

================================================================================
4. SELECTING DATA (Reading Rows)
================================================================================

There are 3 methods for reading data:
1. db.get() - Get ONE row
2. db.all() - Get ALL matching rows
3. db.each() - Process rows ONE AT A TIME

--------------------------------------------------------------------------------
4.1 db.get() - Get Single Row
--------------------------------------------------------------------------------

SYNTAX:
db.get(sql, params, callback);

CALLBACK RECEIVES:
- err: Error object (null if successful)
- row: Single row object (undefined if no match)

EXAMPLE 1 - Get User by ID:
db.get(
  "SELECT * FROM users WHERE id = ?",
  [123],
  (err, row) => {
    if (err) {
      console.error(err.message);
    } else if (row) {
      console.log('User found!');
      console.log('ID:', row.id);
      console.log('Username:', row.username);
      console.log('Email:', row.email);
      console.log('Full row:', row);
    } else {
      console.log('User not found');
    }
  }
);

WHAT row LOOKS LIKE:
{
  id: 123,
  username: 'john_doe',
  email: 'john@example.com',
  password: 'hashed_password',
  created_at: '2024-01-15 10:30:00'
}

EXAMPLE 2 - Check if Username Exists:
db.get(
  "SELECT * FROM users WHERE username = ?",
  ['john_doe'],
  (err, row) => {
    if (row) {
      console.log('Username already taken!');
    } else {
      console.log('Username available!');
    }
  }
);

EXAMPLE 3 - Get Specific Columns:
db.get(
  "SELECT username, email FROM users WHERE id = ?",
  [123],
  (err, row) => {
    if (row) {
      console.log(`${row.username} - ${row.email}`);
      // row only has username and email, not id or password
    }
  }
);

EXAMPLE 4 - Login Check:
const loginUsername = 'john_doe';

db.get(
  "SELECT id, username, password FROM users WHERE username = ?",
  [loginUsername],
  async (err, row) => {
    if (err) {
      console.error(err.message);
    } else if (!row) {
      console.log('User not found');
    } else {
      // Check password (assuming bcrypt)
      const bcrypt = require('bcryptjs');
      const isMatch = await bcrypt.compare(enteredPassword, row.password);
      
      if (isMatch) {
        console.log('Login successful!');
        console.log('User ID:', row.id);
      } else {
        console.log('Wrong password!');
      }
    }
  }
);

USE db.get() WHEN:
- Getting one specific record
- Looking up by ID
- Checking if something exists
- Login verification

--------------------------------------------------------------------------------
4.2 db.all() - Get All Matching Rows
--------------------------------------------------------------------------------

SYNTAX:
db.all(sql, params, callback);

CALLBACK RECEIVES:
- err: Error object (null if successful)
- rows: Array of row objects (empty array [] if no matches)

EXAMPLE 1 - Get All Users:
db.all("SELECT * FROM users", [], (err, rows) => {
  if (err) {
    console.error(err.message);
  } else {
    console.log(`Found ${rows.length} users`);
    
    rows.forEach(user => {
      console.log(`${user.id}: ${user.username} (${user.email})`);
    });
  }
});

WHAT rows LOOKS LIKE:
[
  { id: 1, username: 'john', email: 'john@example.com', ... },
  { id: 2, username: 'alice', email: 'alice@example.com', ... },
  { id: 3, username: 'bob', email: 'bob@example.com', ... }
]

EXAMPLE 2 - Get Users with Filter:
db.all(
  "SELECT * FROM users WHERE created_at > ?",
  ['2024-01-01'],
  (err, rows) => {
    console.log(`${rows.length} users created after 2024-01-01`);
    rows.forEach(user => {
      console.log(user.username, user.created_at);
    });
  }
);

EXAMPLE 3 - Get Specific Columns with Sorting:
db.all(
  "SELECT username, email FROM users ORDER BY username ASC",
  [],
  (err, rows) => {
    if (err) {
      console.error(err.message);
    } else {
      console.log('Users (alphabetically):');
      rows.forEach(user => {
        console.log(`- ${user.username}: ${user.email}`);
      });
    }
  }
);

EXAMPLE 4 - Search with LIKE:
const searchTerm = 'john';

db.all(
  "SELECT * FROM users WHERE username LIKE ? OR email LIKE ?",
  [`%${searchTerm}%`, `%${searchTerm}%`],
  (err, rows) => {
    console.log(`Found ${rows.length} users matching "${searchTerm}"`);
    rows.forEach(user => {
      console.log(user.username, user.email);
    });
  }
);

LIKE PATTERNS:
- '%john%' - Contains 'john' anywhere
- 'john%' - Starts with 'john'
- '%john' - Ends with 'john'
- '%@gmail.com' - Gmail users

EXAMPLE 5 - Pagination:
const page = 2;
const perPage = 10;
const offset = (page - 1) * perPage;

db.all(
  "SELECT * FROM users ORDER BY created_at DESC LIMIT ? OFFSET ?",
  [perPage, offset],
  (err, rows) => {
    console.log(`Page ${page}:`);
    rows.forEach(user => {
      console.log(user.username);
    });
  }
);

PAGINATION EXPLAINED:
- LIMIT: How many rows to return
- OFFSET: How many rows to skip
- Page 1: LIMIT 10 OFFSET 0 (rows 1-10)
- Page 2: LIMIT 10 OFFSET 10 (rows 11-20)
- Page 3: LIMIT 10 OFFSET 20 (rows 21-30)

USE db.all() WHEN:
- Getting multiple records
- Listing all items
- Searching with filters
- Building APIs that return arrays

--------------------------------------------------------------------------------
4.3 db.each() - Process Rows One at a Time
--------------------------------------------------------------------------------

SYNTAX:
db.each(sql, params, rowCallback, completeCallback);

CALLBACKS:
- rowCallback(err, row): Called for EACH row
- completeCallback(err, count): Called AFTER all rows

EXAMPLE 1 - Process All Users:
db.each(
  "SELECT * FROM users",
  [],
  (err, row) => {
    // This runs for EACH user
    if (err) {
      console.error(err.message);
    } else {
      console.log(`Processing user: ${row.username}`);
      // Do something with this user
    }
  },
  (err, count) => {
    // This runs AFTER all users
    if (err) {
      console.error(err.message);
    } else {
      console.log(`Finished processing ${count} users`);
    }
  }
);

EXAMPLE 2 - Send Email to Each User:
db.each(
  "SELECT email, username FROM users WHERE active = 1",
  [],
  (err, row) => {
    if (!err) {
      sendEmail(row.email, `Hello ${row.username}!`);
      console.log(`Email sent to ${row.email}`);
    }
  },
  (err, count) => {
    console.log(`Sent ${count} emails total`);
  }
);

EXAMPLE 3 - Count Something:
let activeCount = 0;
let inactiveCount = 0;

db.each(
  "SELECT status FROM users",
  [],
  (err, row) => {
    if (row.status === 'active') {
      activeCount++;
    } else {
      inactiveCount++;
    }
  },
  (err, count) => {
    console.log(`Active: ${activeCount}, Inactive: ${inactiveCount}`);
    console.log(`Total: ${count}`);
  }
);

USE db.each() WHEN:
- Processing large datasets (memory efficient)
- Doing something with each row individually
- Don't need all rows in memory at once
- Sending emails, processing files, etc.

db.all() vs db.each():
- db.all(): Loads ALL rows into memory at once (faster, uses more memory)
- db.each(): Processes one row at a time (slower, uses less memory)

================================================================================
5. UPDATING DATA (Modifying Rows)
================================================================================

SYNTAX:
db.run("UPDATE table SET col1 = ? WHERE condition", [value], callback);

WARNING: ALWAYS USE WHERE CLAUSE!
- Without WHERE, ALL rows will be updated!
- Bad: UPDATE users SET email = 'same@email.com'  (updates EVERYONE!)
- Good: UPDATE users SET email = ? WHERE id = ?

EXAMPLE 1 - Update Single Field:
db.run(
  "UPDATE users SET email = ? WHERE id = ?",
  ['newemail@example.com', 123],
  function(err) {
    if (err) {
      console.error('Error updating:', err.message);
    } else {
      console.log(`Updated ${this.changes} row(s)`);
      // this.changes = 0 if no row found
      // this.changes = 1 if row updated
    }
  }
);

EXAMPLE 2 - Update Multiple Fields:
db.run(
  "UPDATE users SET username = ?, email = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?",
  ['new_username', 'new_email@example.com', 123],
  function(err) {
    if (err) {
      console.error(err.message);
    } else {
      if (this.changes === 0) {
        console.log('User not found');
      } else {
        console.log('User updated successfully');
      }
    }
  }
);

EXAMPLE 3 - Update Multiple Rows:
db.run(
  "UPDATE users SET status = ? WHERE created_at < ?",
  ['inactive', '2020-01-01'],
  function(err) {
    if (err) {
      console.error(err.message);
    } else {
      console.log(`Marked ${this.changes} users as inactive`);
    }
  }
);

EXAMPLE 4 - Increment a Value:
db.run(
  "UPDATE products SET stock = stock + ? WHERE id = ?",
  [10, 5],  // Add 10 to stock for product 5
  function(err) {
    if (err) {
      console.error(err.message);
    } else {
      console.log('Stock updated');
    }
  }
);

EXAMPLE 5 - Conditional Update:
db.run(
  "UPDATE users SET login_count = login_count + 1, last_login = CURRENT_TIMESTAMP WHERE username = ?",
  ['john_doe'],
  function(err) {
    if (err) {
      console.error(err.message);
    } else {
      console.log('Login recorded');
    }
  }
);

================================================================================
6. DELETING DATA (Removing Rows)
================================================================================

SYNTAX:
db.run("DELETE FROM table WHERE condition", params, callback);

WARNING: ALWAYS USE WHERE CLAUSE!
- Without WHERE, ALL rows will be deleted!
- Bad: DELETE FROM users  (deletes EVERYONE!)
- Good: DELETE FROM users WHERE id = ?

EXAMPLE 1 - Delete Single User:
db.run(
  "DELETE FROM users WHERE id = ?",
  [123],
  function(err) {
    if (err) {
      console.error('Error deleting:', err.message);
    } else {
      if (this.changes === 0) {
        console.log('User not found');
      } else {
        console.log('User deleted successfully');
      }
    }
  }
);

EXAMPLE 2 - Delete Multiple Rows:
db.run(
  "DELETE FROM users WHERE created_at < ?",
  ['2020-01-01'],
  function(err) {
    if (err) {
      console.error(err.message);
    } else {
      console.log(`Deleted ${this.changes} old users`);
    }
  }
);

EXAMPLE 3 - Delete with Confirmation:
const userId = 123;

// First, get the user to confirm
db.get("SELECT username FROM users WHERE id = ?", [userId], (err, row) => {
  if (err) {
    console.error(err.message);
  } else if (!row) {
    console.log('User not found');
  } else {
    console.log(`Are you sure you want to delete ${row.username}?`);
    
    // If confirmed, delete
    db.run("DELETE FROM users WHERE id = ?", [userId], function(err) {
      if (err) {
        console.error(err.message);
      } else {
        console.log(`Deleted user: ${row.username}`);
      }
    });
  }
});

EXAMPLE 4 - Soft Delete (Mark as Deleted Instead):
// Instead of actually deleting, just mark as deleted
db.run(
  "UPDATE users SET deleted = 1, deleted_at = CURRENT_TIMESTAMP WHERE id = ?",
  [123],
  function(err) {
    if (err) {
      console.error(err.message);
    } else {
      console.log('User marked as deleted');
    }
  }
);

// Then in queries, exclude deleted users:
db.all("SELECT * FROM users WHERE deleted = 0", [], (err, rows) => {
  // Only get non-deleted users
});

WHY SOFT DELETE?
- Can recover deleted data
- Keep history/audit trail
- Safer than permanent deletion

================================================================================
7. TRANSACTIONS (All or Nothing)
================================================================================

WHAT ARE TRANSACTIONS?
Imagine transferring money:
1. Subtract $100 from Account A
2. Add $100 to Account B

If step 2 fails, you want to undo step 1! Otherwise Account A loses money
but Account B doesn't get it. Transactions ensure ALL steps succeed or ALL fail.

SYNTAX:
db.serialize(() => {
  db.run("BEGIN TRANSACTION");
  db.run("SQL statement 1");
  db.run("SQL statement 2");
  db.run("COMMIT");  // Save all changes
  // OR
  db.run("ROLLBACK");  // Undo all changes
});

KEYWORDS:
- BEGIN TRANSACTION: Start transaction
- COMMIT: Save all changes (make them permanent)
- ROLLBACK: Undo all changes (cancel everything)
- db.serialize(): Run commands in order (not parallel)

EXAMPLE 1 - Transfer Money:
const fromAccount = 1;
const toAccount = 2;
const amount = 100;

db.serialize(() => {
  db.run("BEGIN TRANSACTION");
  
  // Subtract from Account A
  db.run(
    "UPDATE accounts SET balance = balance - ? WHERE id = ?",
    [amount, fromAccount],
    (err) => {
      if (err) {
        console.error('Error subtracting:', err.message);
        db.run("ROLLBACK");  // Undo everything!
        return;
      }
    }
  );
  
  // Add to Account B
  db.run(
    "UPDATE accounts SET balance = balance + ? WHERE id = ?",
    [amount, toAccount],
    (err) => {
      if (err) {
        console.error('Error adding:', err.message);
        db.run("ROLLBACK");  // Undo everything!
      } else {
        db.run("COMMIT");  // Save everything!
        console.log('Transfer successful!');
      }
    }
  );
});

EXAMPLE 2 - Create User with Profile:
db.serialize(() => {
  db.run("BEGIN TRANSACTION");
  
  // Insert user
  db.run(
    "INSERT INTO users (username, email) VALUES (?, ?)",
    ['john', 'john@example.com'],
    function(err) {
      if (err) {
        db.run("ROLLBACK");
        return;
      }
      
      const userId = this.lastID;
      
      // Insert profile
      db.run(
        "INSERT INTO profiles (user_id, bio, avatar) VALUES (?, ?, ?)",
        [userId, 'Hello!', 'avatar.jpg'],
        (err) => {
          if (err) {
            db.run("ROLLBACK");  // Undo user insert too!
          } else {
            db.run("COMMIT");  // Save both!
            console.log('User and profile created!');
          }
        }
      );
    }
  );
});

EXAMPLE 3 - Bulk Insert with Transaction:
const users = [
  ['alice', 'alice@example.com'],
  ['bob', 'bob@example.com'],
  ['charlie', 'charlie@example.com']
];

db.serialize(() => {
  db.run("BEGIN TRANSACTION");
  
  const stmt = db.prepare("INSERT INTO users (username, email) VALUES (?, ?)");
  
  let hasError = false;
  
  users.forEach(user => {
    stmt.run(user, (err) => {
      if (err) {
        hasError = true;
        console.error(err.message);
      }
    });
  });
  
  stmt.finalize(() => {
    if (hasError) {
      db.run("ROLLBACK");  // Undo all inserts
      console.log('Transaction rolled back');
    } else {
      db.run("COMMIT");  // Save all inserts
      console.log('All users inserted!');
    }
  });
});

WHEN TO USE TRANSACTIONS:
- Multiple related operations
- Financial operations (transfers, payments)
- Creating related records (user + profile)
- Ensuring data consistency
- Bulk operations that must all succeed

================================================================================
8. CLOSING DATABASE CONNECTION
================================================================================

SYNTAX:
db.close(callback);

EXAMPLE:
db.close((err) => {
  if (err) {
    console.error('Error closing database:', err.message);
  } else {
    console.log('Database connection closed');
  }
});

WHEN TO CLOSE:
- When your app shuts down
- After finishing all database operations
- Before exiting the program
- In cleanup/shutdown handlers

EXAMPLE - Graceful Shutdown:
process.on('SIGINT', () => {
  console.log('Shutting down...');
  
  db.close((err) => {
    if (err) {
      console.error(err.message);
    } else {
      console.log('Database closed');
    }
    process.exit(0);
  });
});

================================================================================
9. COMPLETE REAL-WORLD EXAMPLE - User Management System
================================================================================

const sqlite3 = require('sqlite3').verbose();
const db = new sqlite3.Database('users.db');

// Create table
db.run(`
  CREATE TABLE IF NOT EXISTS users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    username TEXT NOT NULL UNIQUE,
    email TEXT NOT NULL UNIQUE,
    password TEXT NOT NULL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
  )
`);

// CREATE - Insert user
function createUser(username, email, password, callback) {
  db.run(
    "INSERT INTO users (username, email, password) VALUES (?, ?, ?)",
    [username, email, password],
    function(err) {
      if (err) {
        callback(err, null);
      } else {
        callback(null, {
          id: this.lastID,
          username,
          email
        });
      }
    }
  );
}

// READ - Get user by ID
function getUserById(id, callback) {
  db.get(
    "SELECT id, username, email, created_at FROM users WHERE id = ?",
    [id],
    (err, row) => {
      callback(err, row);
    }
  );
}

// READ - Get all users
function getAllUsers(callback) {
  db.all(
    "SELECT id, username, email, created_at FROM users ORDER BY created_at DESC",
    [],
    (err, rows) => {
      callback(err, rows);
    }
  );
}

// UPDATE - Update user email
function updateUserEmail(id, newEmail, callback) {
  db.run(
    "UPDATE users SET email = ? WHERE id = ?",
    [newEmail, id],
    function(err) {
      callback(err, this.changes);
    }
  );
}

// DELETE - Delete user
function deleteUser(id, callback) {
  db.run(
    "DELETE FROM users WHERE id = ?",
    [id],
    function(err) {
      callback(err, this.changes);
    }
  );
}

// SEARCH - Find users
function searchUsers(searchTerm, callback) {
  db.all(
    "SELECT id, username, email FROM users WHERE username LIKE ? OR email LIKE ?",
    [`%${searchTerm}%`, `%${searchTerm}%`],
    (err, rows) => {
      callback(err, rows);
    }
  );
}

// Usage examples:

// Create user
createUser('john_doe', 'john@example.com', 'hashed_pass', (err, user) => {
  if (err) {
    console.error('Error creating user:', err.message);
  } else {
    console.log('User created:', user);
  }
});

// Get user
getUserById(1, (err, user) => {
  if (err) {
    console.error(err.message);
  } else if (user) {
    console.log('User found:', user);
  } else {
    console.log('User not found');
  }
});

// Get all users
getAllUsers((err, users) => {
  if (err) {
    console.error(err.message);
  } else {
    console.log(`Found ${users.length} users:`);
    users.forEach(user => {
      console.log(`- ${user.username} (${user.email})`);
    });
  }
});

// Update user
updateUserEmail(1, 'newemail@example.com', (err, changes) => {
  if (err) {
    console.error(err.message);
  } else if (changes === 0) {
    console.log('User not found');
  } else {
    console.log('Email updated!');
  }
});

// Delete user
deleteUser(1, (err, changes) => {
  if (err) {
    console.error(err.message);
  } else if (changes === 0) {
    console.log('User not found');
  } else {
    console.log('User deleted!');
  }
});

// Search users
searchUsers('john', (err, users) => {
  if (err) {
    console.error(err.message);
  } else {
    console.log(`Found ${users.length} users matching "john"`);
  }
});

================================================================================
10. COMMON SQL QUERIES REFERENCE
================================================================================

SELECT QUERIES:
---------------

// Get all columns, all rows
SELECT * FROM users

// Get specific columns
SELECT username, email FROM users

// Filter with WHERE
SELECT * FROM users WHERE id = 123
SELECT * FROM users WHERE username = 'john'
SELECT * FROM users WHERE age > 18

// Multiple conditions (AND)
SELECT * FROM users WHERE age > 18 AND status = 'active'

// Multiple conditions (OR)
SELECT * FROM users WHERE city = 'NYC' OR city = 'LA'

// Sorting (ASC = ascending, DESC = descending)
SELECT * FROM users ORDER BY username ASC
SELECT * FROM users ORDER BY created_at DESC

// Limit results
SELECT * FROM users LIMIT 10
SELECT * FROM users LIMIT 10 OFFSET 20

// Count rows
SELECT COUNT(*) as total FROM users
SELECT COUNT(*) FROM users WHERE status = 'active'

// Search with LIKE
SELECT * FROM users WHERE username LIKE '%john%'
SELECT * FROM users WHERE email LIKE '%@gmail.com'

// Get unique values
SELECT DISTINCT city FROM users

// Group by
SELECT city, COUNT(*) as count FROM users GROUP BY city

// Join tables
SELECT users.username, posts.title
FROM users
INNER JOIN posts ON users.id = posts.user_id

================================================================================
11. BEST PRACTICES
================================================================================

1. ALWAYS use parameterized queries (? placeholders)
   Bad:  `SELECT * FROM users WHERE id = ${userId}`  // SQL INJECTION!
   Good: `SELECT * FROM users WHERE id = ?`, [userId]

2. Use transactions for related operations
   - Ensures all succeed or all fail
   - Maintains data consistency

3. Close database connections
   - Prevents memory leaks
   - Releases file locks
   - db.close() when done

4. Handle errors properly
   - Always check err in callbacks
   - Log errors for debugging
   - Provide user-friendly messages

5. Use indexes for faster queries
   CREATE INDEX idx_username ON users(username);
   - Makes searches much faster
   - Especially for large tables

6. Don't store sensitive data in plain text
   - Hash passwords with bcrypt
   - Encrypt sensitive information
   - Never log passwords

7. Use db.serialize() for sequential operations
   - Ensures operations run in order
   - Important for transactions

8. Use prepared statements for multiple inserts
   - Much faster than individual inserts
   - Still safe from SQL injection

9. Validate data before inserting
   - Check required fields
   - Validate email format
   - Check data types

10. Use meaningful column names
    - Good: created_at, user_id, email_address
    - Bad: c, uid, e

================================================================================
END OF SQLITE3 DETAILED GUIDE
================================================================================
